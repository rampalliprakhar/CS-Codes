/* -------------------------------------------------
 * Author: Prakhar Rampalli
 * Written: 2/5/23
 * Last Updated: 2/5/23
 *
 * Compilation: javac HashTableTest.java
 * Execution: java HashTableTest
 *
 * Description:
 * A program which implements HashTable using quadratic probing.
 * The HashTable<Key, Value> class is tested in the main method.
 * Implements: default constructor, parameterized constructor, put, remove, get, contains, resize.
 * 
 * Sample Output:
 * Enter some lowercase characters to store as keys in the hash table 
 *	(Their uppercase equivalents will be used as the corresponding values):
 *	quadratic
 *	
 *	0 : null/null
 *	1 : q/Q
 *	2 : a/A
 *	3 : r/R
 *	4 : d/D
 *	5 : u/U
 *	6 : null/null
 *	7 : null/null
 *	8 : c/C
 *	9 : t/T
 *	10 : i/I
 *	11 : null/null
 *	12 : null/null
 *	13 : null/null
 *	14 : null/null
 *	15 : null/null
 *	
 *	Testing retrieval:
 *	QUADRATIC
 *	
 *	Now enter one or more lowercase character keys to delete from the hash table: 
 *	rq
 *	
 *	Testing retrieval after deletion:
 *	-UAD-ATIC
 * 
 -------------------------------------------------*/
public class HashTable<Key,Value> {
   private int size;              // how many key/value pairs are stored
   private int arrayLength;       // size of the array (and consequently, the mod)
   private Key[] keys;
   private Value[] vals;
   private boolean[] tombstones;  // true if element at this index has been deleted, false otherwise
   
   public HashTable() {  
       this(16);  // chains to the other constructor with 1 specified as capacity.
   }

   // size of HashTable
   public HashTable(int capacity) {
	   size = 0; // assuming the size is 0
	   arrayLength = capacity; // assuming arrayLength is capacity
	   keys = (Key[]) new Character[arrayLength]; // putting arrayLength in key
	   vals = (Value[]) new Character[arrayLength]; // putting arrayLength in vals
	   tombstones = new boolean[arrayLength]; // putting arrayLength in tombstones
	   for(int i=0;i<tombstones.length;i++) { // it traverses through boolean tombstone's length
	     tombstones[i] = false; // assuming tombstones element is false;
	   }
   }
   // method for hash function
   private int hash(Key key) {
      return (key.hashCode() % arrayLength);
   }
   // converts elements of keys and values to string
   public String toString() { 
       String s = "";
       for (int i = 0; i < arrayLength; i++) {
           s += i + " : " + keys[i] + "/" + vals[i] + "\n";
       }
       return s;
   }
   
   // insert or update the value associated with the given key 
   // in the array by hashing and handling any collisions
   public void put(Key key, Value val) {    
	   int find_value = hash(key); // find_value finds the hash of the given key
	   int index = find_value, h=1; // assuming index to be find_value and h as collision number
	   
	   do
	   {
		   if(keys[index]==null) // checking to see whether keys containing find_value is empty
		   {
			   keys[index] = key; // keys containing find_value is the given key
			   vals[index] = val; // vals containing find_value is the given val
			   size++; // incrementing size
			   return;
		   }
		   
		   if(keys[index].equals(key)) // checking to see whether keys containing new value matches the given key
		   {
			   vals[index] = val; // if same, then the vals of new_value is the given val;
			   return;
		   }
		   
		   index = (index + h * h++) % arrayLength; // if not, then applying the quadratic probing formula
		   
	   }while(index != find_value); // checks to see whether index is not equal to find_value
	   int load_factor = size / arrayLength;
	   if(load_factor >= 0.5) { // create loadfactor for hashtable which occurs by dividing size/total capacity
		   resize(arrayLength * 2); // recursively call resize method which doubles the capacity when inserting element
	   }
	   keys[index++] = key; //incrementing index of keys
	   vals[index++] = val; //incrementing index of value
   }
   
// get the value associated with a given key
   public Value get(Key key) {
	   int index = hash(key), h = 1; // assuming index stores the number generated by the hash function and h to be collision number
       while (keys[index] != null) // Till keys containing index is not empty
       {
           if (keys[index].equals(key)) // checking whether keys containing index matches given key
               return vals[index]; // if matches, returns the associated value of the key
           index = (index + h * h++) % arrayLength; // if not, then uses quadratic probing to access the key
       }            
       return null; // if keys containing index is empty
   }
   
// method checking to see whether given key is present in the table
   public boolean contains(Key key) {
	   return get(key) !=  null; // directly returning key using get method when not empty
   }

// method deleting the given key from the hash table
   public void delete(Key key) {
	   if (!contains(key)) // checking to see whether the hashtable contains the key 
           return;
	   // if given key is not present, then finding the key using quadratic probing and deleting it

       int index = hash(key), h = 1; // assuming index stores the number generated by the hash function and h to be collision number
       while (!key.equals(keys[index]) && tombstones[index] == false)
       {   // checking to see whether given key does not match the keys index and tombstones index is false
           index = (index + h * h++) % arrayLength; // using quadratic probing to find the position
       }
       keys[index] = null; // when position is found, assuming keys index to be null 
       vals[index] = null; // assuming vals index to be null
       tombstones[index] = true; // when deletion successful, return tombstones index as true
       int load_factor = size / arrayLength; // create loadfactor for hashtable which occurs by dividing size/total capacity
       if(load_factor < 0.125) { // when load_factor is less than 0.125 or 1/8
    	   resize(arrayLength / 2); // the size will be half thereby calling recursively
    	   keys[index--] = key; // keys of index decrements by 1
       }
   }
   
// method resizing the array to have the given capacity (requires a rehashing of all items).
   private void resize(int capacity) 
   {	//Key key = new Key();
   		int load_factor = size / arrayLength; // create load_factor which divides size by total hash size
   		if(load_factor >= 0.5) { // checking to see if load_factor is greater than or equal to (0.5) or (1/2)
   			resize(capacity * 2); // calling recursively by multiplying capacity with 2
   		}      
   }
}

import java.util.Scanner;

public class HashTableTest {
    
   public static void main(String[] args) {
       Scanner scanner = new Scanner(System.in);
       System.out.println("Enter some lowercase characters to store as keys in the hash table ");
       System.out.println("(Their uppercase equivalents will be used as the corresponding values):");
       String charsToHash = scanner.nextLine();
       System.out.println();
       
       HashTable<Character,Character> ht = new HashTable<Character,Character>();

       for (int i = 0; i < charsToHash.length(); i++) {
           ht.put(charsToHash.charAt(i), charsToHash.toUpperCase().charAt(i));
       }
       
       System.out.println(ht);
       
       System.out.println("Testing retrieval:");
       for (int i = 0; i < charsToHash.length(); i++) {
           System.out.print(ht.get(charsToHash.charAt(i)));
       }
       System.out.println("\n");
       
       System.out.println("Now enter one or more lowercase character keys to delete from the hash table: ");
       String charsToDelete = scanner.nextLine();
       scanner.close();
       for (int i = 0; i < charsToDelete.length(); i++) {
           ht.delete(charsToDelete.charAt(i));
       }
       System.out.println();
       
       System.out.println("Testing retrieval after deletion:");
       for (int i = 0; i < charsToHash.length(); i++) {
           Character v = ht.get(charsToHash.charAt(i));
           System.out.print(v != null ? v : '-');
       }
   }
}